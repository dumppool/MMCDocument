<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PyHost Code Analysis - /usr/local/include/eigen3/Eigen/src/Core/util/XprHelper.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">usr/local/include/eigen3/Eigen/src/Core/util</a> - XprHelper.h<span style="font-size: 80%;"> (source / <a href="XprHelper.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PyHost Code Analysis</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryMed">84.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-08-16 17:04:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntryMed">78.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // This file is part of Eigen, a lightweight C++ template library</a>
<span class="lineNum">       2 </span>            : // for linear algebra.
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : // Copyright (C) 2008 Gael Guennebaud &lt;gael.guennebaud@inria.fr&gt;
<span class="lineNum">       5 </span>            : // Copyright (C) 2006-2008 Benoit Jacob &lt;jacob.benoit.1@gmail.com&gt;
<span class="lineNum">       6 </span>            : //
<span class="lineNum">       7 </span>            : // This Source Code Form is subject to the terms of the Mozilla
<span class="lineNum">       8 </span>            : // Public License v. 2.0. If a copy of the MPL was not distributed
<span class="lineNum">       9 </span>            : // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #ifndef EIGEN_XPRHELPER_H
<span class="lineNum">      12 </span>            : #define EIGEN_XPRHELPER_H
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : // just a workaround because GCC seems to not really like empty structs
<span class="lineNum">      15 </span>            : // FIXME: gcc 4.3 generates bad code when strict-aliasing is enabled
<span class="lineNum">      16 </span>            : // so currently we simply disable this optimization for gcc 4.3
<span class="lineNum">      17 </span>            : #if EIGEN_COMP_GNUC &amp;&amp; !EIGEN_GNUC_AT(4,3)
<span class="lineNum">      18 </span>            :   #define EIGEN_EMPTY_STRUCT_CTOR(X) \
<span class="lineNum">      19 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X() {} \
<span class="lineNum">      20 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X(const X&amp; ) {}
<span class="lineNum">      21 </span>            : #else
<span class="lineNum">      22 </span>            :   #define EIGEN_EMPTY_STRUCT_CTOR(X)
<span class="lineNum">      23 </span>            : #endif
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : namespace Eigen {
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : namespace internal {
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : template&lt;typename IndexDest, typename IndexSrc&gt;
<span class="lineNum">      30 </span>            : EIGEN_DEVICE_FUNC
<span class="lineNum">      31 </span>            : inline IndexDest convert_index(const IndexSrc&amp; idx) {
<span class="lineNum">      32 </span>            :   // for sizeof(IndexDest)&gt;=sizeof(IndexSrc) compilers should be able to optimize this away:
<span class="lineNum">      33 </span>            :   eigen_internal_assert(idx &lt;= NumTraits&lt;IndexDest&gt;::highest() &amp;&amp; &quot;Index value to big for target type&quot;);
<span class="lineNum">      34 </span>            :   return IndexDest(idx);
<span class="lineNum">      35 </span>            : }
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : // promote_scalar_arg is an helper used in operation between an expression and a scalar, like:
<span class="lineNum">      39 </span>            : //    expression * scalar
<span class="lineNum">      40 </span>            : // Its role is to determine how the type T of the scalar operand should be promoted given the scalar type ExprScalar of the given expression.
<span class="lineNum">      41 </span>            : // The IsSupported template parameter must be provided by the caller as: internal::has_ReturnType&lt;ScalarBinaryOpTraits&lt;ExprScalar,T,op&gt; &gt;::value using the proper order for ExprScalar and T.
<span class="lineNum">      42 </span>            : // Then the logic is as follows:
<span class="lineNum">      43 </span>            : //  - if the operation is natively supported as defined by IsSupported, then the scalar type is not promoted, and T is returned.
<span class="lineNum">      44 </span>            : //  - otherwise, NumTraits&lt;ExprScalar&gt;::Literal is returned if T is implicitly convertible to NumTraits&lt;ExprScalar&gt;::Literal AND that this does not imply a float to integer conversion.
<span class="lineNum">      45 </span>            : //  - otherwise, ExprScalar is returned if T is implicitly convertible to ExprScalar AND that this does not imply a float to integer conversion.
<span class="lineNum">      46 </span>            : //  - In all other cases, the promoted type is not defined, and the respective operation is thus invalid and not available (SFINAE).
<span class="lineNum">      47 </span>            : template&lt;typename ExprScalar,typename T, bool IsSupported&gt;
<span class="lineNum">      48 </span>            : struct promote_scalar_arg;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : template&lt;typename S,typename T&gt;
<span class="lineNum">      51 </span>            : struct promote_scalar_arg&lt;S,T,true&gt;
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            :   typedef T type;
<span class="lineNum">      54 </span>            : };
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : // Recursively check safe conversion to PromotedType, and then ExprScalar if they are different.
<span class="lineNum">      57 </span>            : template&lt;typename ExprScalar,typename T,typename PromotedType,
<span class="lineNum">      58 </span>            :   bool ConvertibleToLiteral = internal::is_convertible&lt;T,PromotedType&gt;::value,
<span class="lineNum">      59 </span>            :   bool IsSafe = NumTraits&lt;T&gt;::IsInteger || !NumTraits&lt;PromotedType&gt;::IsInteger&gt;
<span class="lineNum">      60 </span>            : struct promote_scalar_arg_unsupported;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : // Start recursion with NumTraits&lt;ExprScalar&gt;::Literal
<span class="lineNum">      63 </span>            : template&lt;typename S,typename T&gt;
<span class="lineNum">      64 </span>            : struct promote_scalar_arg&lt;S,T,false&gt; : promote_scalar_arg_unsupported&lt;S,T,typename NumTraits&lt;S&gt;::Literal&gt; {};
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : // We found a match!
<span class="lineNum">      67 </span>            : template&lt;typename S,typename T, typename PromotedType&gt;
<span class="lineNum">      68 </span>            : struct promote_scalar_arg_unsupported&lt;S,T,PromotedType,true,true&gt;
<span class="lineNum">      69 </span>            : {
<span class="lineNum">      70 </span>            :   typedef PromotedType type;
<span class="lineNum">      71 </span>            : };
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : // No match, but no real-to-integer issues, and ExprScalar and current PromotedType are different,
<span class="lineNum">      74 </span>            : // so let's try to promote to ExprScalar
<span class="lineNum">      75 </span>            : template&lt;typename ExprScalar,typename T, typename PromotedType&gt;
<span class="lineNum">      76 </span>            : struct promote_scalar_arg_unsupported&lt;ExprScalar,T,PromotedType,false,true&gt;
<span class="lineNum">      77 </span>            :    : promote_scalar_arg_unsupported&lt;ExprScalar,T,ExprScalar&gt;
<span class="lineNum">      78 </span>            : {};
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : // Unsafe real-to-integer, let's stop.
<span class="lineNum">      81 </span>            : template&lt;typename S,typename T, typename PromotedType, bool ConvertibleToLiteral&gt;
<span class="lineNum">      82 </span>            : struct promote_scalar_arg_unsupported&lt;S,T,PromotedType,ConvertibleToLiteral,false&gt; {};
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : // T is not even convertible to ExprScalar, let's stop.
<span class="lineNum">      85 </span>            : template&lt;typename S,typename T&gt;
<span class="lineNum">      86 </span>            : struct promote_scalar_arg_unsupported&lt;S,T,S,false,true&gt; {};
<a name="87"><span class="lineNum">      87 </span>            : </a>
<span class="lineNum">      88 </span>            : //classes inheriting no_assignment_operator don't generate a default operator=.
<span class="lineNum">      89 </span><span class="lineCov">    2064891 : class no_assignment_operator</span>
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span>            :   private:
<span class="lineNum">      92 </span>            :     no_assignment_operator&amp; operator=(const no_assignment_operator&amp;);
<span class="lineNum">      93 </span>            : };
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : /** \internal return the index type with the largest number of bits */
<span class="lineNum">      96 </span>            : template&lt;typename I1, typename I2&gt;
<span class="lineNum">      97 </span>            : struct promote_index_type
<span class="lineNum">      98 </span>            : {
<span class="lineNum">      99 </span>            :   typedef typename conditional&lt;(sizeof(I1)&lt;sizeof(I2)), I2, I1&gt;::type type;
<span class="lineNum">     100 </span>            : };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : /** \internal If the template parameter Value is Dynamic, this class is just a wrapper around a T variable that
<span class="lineNum">     103 </span>            :   * can be accessed using value() and setValue().
<span class="lineNum">     104 </span>            :   * Otherwise, this class is an empty structure and value() just returns the template parameter Value.
<span class="lineNum">     105 </span>            :   */
<span class="lineNum">     106 </span>            : template&lt;typename T, int Value&gt; class variable_if_dynamic
<a name="107"><span class="lineNum">     107 </span>            : {</a>
<a name="108"><span class="lineNum">     108 </span>            :   public:</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">    5226466 :     EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamic)</span></a>
<span class="lineNum">     110 </span><span class="lineCov">   18452990 :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }</span>
<span class="lineNum">     111 </span><span class="lineCov">   70061668 :     EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }</span>
<span class="lineNum">     112 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
<span class="lineNum">     113 </span>            : };
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : template&lt;typename T&gt; class variable_if_dynamic&lt;T, Dynamic&gt;
<span class="lineNum">     116 </span>            : {
<span class="lineNum">     117 </span>            :     T m_value;
<a name="118"><span class="lineNum">     118 </span>            :     EIGEN_DEVICE_FUNC variable_if_dynamic() { eigen_assert(false); }</a>
<a name="119"><span class="lineNum">     119 </span>            :   public:</a>
<span class="lineNum">     120 </span><span class="lineCov">   15854742 :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T value) : m_value(value) {}</span>
<span class="lineNum">     121 </span><span class="lineCov">   25430807 :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T value() const { return m_value; }</span>
<span class="lineNum">     122 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T value) { m_value = value; }
<span class="lineNum">     123 </span>            : };
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : /** \internal like variable_if_dynamic but for DynamicIndex
<span class="lineNum">     126 </span>            :   */
<span class="lineNum">     127 </span>            : template&lt;typename T, int Value&gt; class variable_if_dynamicindex
<a name="128"><span class="lineNum">     128 </span>            : {</a>
<a name="129"><span class="lineNum">     129 </span>            :   public:</a>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">      99640 :     EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamicindex)</span></a>
<span class="lineNum">     131 </span><span class="lineCov">      81310 :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }</span>
<span class="lineNum">     132 </span><span class="lineCov">     584210 :     EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }</span>
<span class="lineNum">     133 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
<span class="lineNum">     134 </span>            : };
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : template&lt;typename T&gt; class variable_if_dynamicindex&lt;T, DynamicIndex&gt;
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span>            :     T m_value;
<span class="lineNum">     139 </span>            :     EIGEN_DEVICE_FUNC variable_if_dynamicindex() { eigen_assert(false); }
<span class="lineNum">     140 </span>            :   public:
<span class="lineNum">     141 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T value) : m_value(value) {}
<span class="lineNum">     142 </span>            :     EIGEN_DEVICE_FUNC T EIGEN_STRONG_INLINE value() const { return m_value; }
<span class="lineNum">     143 </span>            :     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T value) { m_value = value; }
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : template&lt;typename T&gt; struct functor_traits
<span class="lineNum">     147 </span>            : {
<span class="lineNum">     148 </span>            :   enum
<span class="lineNum">     149 </span>            :   {
<span class="lineNum">     150 </span>            :     Cost = 10,
<span class="lineNum">     151 </span>            :     PacketAccess = false,
<span class="lineNum">     152 </span>            :     IsRepeatable = false
<span class="lineNum">     153 </span>            :   };
<span class="lineNum">     154 </span>            : };
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : template&lt;typename T&gt; struct packet_traits;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : template&lt;typename T&gt; struct unpacket_traits
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span>            :   typedef T type;
<span class="lineNum">     161 </span>            :   typedef T half;
<span class="lineNum">     162 </span>            :   enum
<span class="lineNum">     163 </span>            :   {
<span class="lineNum">     164 </span>            :     size = 1,
<span class="lineNum">     165 </span>            :     alignment = 1
<span class="lineNum">     166 </span>            :   };
<span class="lineNum">     167 </span>            : };
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : template&lt;int Size, typename PacketType,
<span class="lineNum">     170 </span>            :          bool Stop = Size==Dynamic || (Size%unpacket_traits&lt;PacketType&gt;::size)==0 || is_same&lt;PacketType,typename unpacket_traits&lt;PacketType&gt;::half&gt;::value&gt;
<span class="lineNum">     171 </span>            : struct find_best_packet_helper;
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : template&lt; int Size, typename PacketType&gt;
<span class="lineNum">     174 </span>            : struct find_best_packet_helper&lt;Size,PacketType,true&gt;
<span class="lineNum">     175 </span>            : {
<span class="lineNum">     176 </span>            :   typedef PacketType type;
<span class="lineNum">     177 </span>            : };
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : template&lt;int Size, typename PacketType&gt;
<span class="lineNum">     180 </span>            : struct find_best_packet_helper&lt;Size,PacketType,false&gt;
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span>            :   typedef typename find_best_packet_helper&lt;Size,typename unpacket_traits&lt;PacketType&gt;::half&gt;::type type;
<span class="lineNum">     183 </span>            : };
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : template&lt;typename T, int Size&gt;
<span class="lineNum">     186 </span>            : struct find_best_packet
<span class="lineNum">     187 </span>            : {
<span class="lineNum">     188 </span>            :   typedef typename find_best_packet_helper&lt;Size,typename packet_traits&lt;T&gt;::type&gt;::type type;
<span class="lineNum">     189 </span>            : };
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : #if EIGEN_MAX_STATIC_ALIGN_BYTES&gt;0
<span class="lineNum">     192 </span>            : template&lt;int ArrayBytes, int AlignmentBytes,
<span class="lineNum">     193 </span>            :          bool Match     =  bool((ArrayBytes%AlignmentBytes)==0),
<span class="lineNum">     194 </span>            :          bool TryHalf   =  bool(EIGEN_MIN_ALIGN_BYTES&lt;AlignmentBytes) &gt;
<span class="lineNum">     195 </span>            : struct compute_default_alignment_helper
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span>            :   enum { value = 0 };
<span class="lineNum">     198 </span>            : };
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : template&lt;int ArrayBytes, int AlignmentBytes, bool TryHalf&gt;
<span class="lineNum">     201 </span>            : struct compute_default_alignment_helper&lt;ArrayBytes, AlignmentBytes, true, TryHalf&gt; // Match
<span class="lineNum">     202 </span>            : {
<span class="lineNum">     203 </span>            :   enum { value = AlignmentBytes };
<span class="lineNum">     204 </span>            : };
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : template&lt;int ArrayBytes, int AlignmentBytes&gt;
<span class="lineNum">     207 </span>            : struct compute_default_alignment_helper&lt;ArrayBytes, AlignmentBytes, false, true&gt; // Try-half
<span class="lineNum">     208 </span>            : {
<span class="lineNum">     209 </span>            :   // current packet too large, try with an half-packet
<span class="lineNum">     210 </span>            :   enum { value = compute_default_alignment_helper&lt;ArrayBytes, AlignmentBytes/2&gt;::value };
<span class="lineNum">     211 </span>            : };
<span class="lineNum">     212 </span>            : #else
<span class="lineNum">     213 </span>            : // If static alignment is disabled, no need to bother.
<span class="lineNum">     214 </span>            : // This also avoids a division by zero in &quot;bool Match =  bool((ArrayBytes%AlignmentBytes)==0)&quot;
<span class="lineNum">     215 </span>            : template&lt;int ArrayBytes, int AlignmentBytes&gt;
<span class="lineNum">     216 </span>            : struct compute_default_alignment_helper
<span class="lineNum">     217 </span>            : {
<span class="lineNum">     218 </span>            :   enum { value = 0 };
<span class="lineNum">     219 </span>            : };
<span class="lineNum">     220 </span>            : #endif
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : template&lt;typename T, int Size&gt; struct compute_default_alignment {
<span class="lineNum">     223 </span>            :   enum { value = compute_default_alignment_helper&lt;Size*sizeof(T),EIGEN_MAX_STATIC_ALIGN_BYTES&gt;::value };
<span class="lineNum">     224 </span>            : };
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : template&lt;typename T&gt; struct compute_default_alignment&lt;T,Dynamic&gt; {
<span class="lineNum">     227 </span>            :   enum { value = EIGEN_MAX_ALIGN_BYTES };
<span class="lineNum">     228 </span>            : };
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : template&lt;typename _Scalar, int _Rows, int _Cols,
<span class="lineNum">     231 </span>            :          int _Options = AutoAlign |
<span class="lineNum">     232 </span>            :                           ( (_Rows==1 &amp;&amp; _Cols!=1) ? RowMajor
<span class="lineNum">     233 </span>            :                           : (_Cols==1 &amp;&amp; _Rows!=1) ? ColMajor
<span class="lineNum">     234 </span>            :                           : EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION ),
<span class="lineNum">     235 </span>            :          int _MaxRows = _Rows,
<span class="lineNum">     236 </span>            :          int _MaxCols = _Cols
<span class="lineNum">     237 </span>            : &gt; class make_proper_matrix_type
<span class="lineNum">     238 </span>            : {
<span class="lineNum">     239 </span>            :     enum {
<span class="lineNum">     240 </span>            :       IsColVector = _Cols==1 &amp;&amp; _Rows!=1,
<span class="lineNum">     241 </span>            :       IsRowVector = _Rows==1 &amp;&amp; _Cols!=1,
<span class="lineNum">     242 </span>            :       Options = IsColVector ? (_Options | ColMajor) &amp; ~RowMajor
<span class="lineNum">     243 </span>            :               : IsRowVector ? (_Options | RowMajor) &amp; ~ColMajor
<span class="lineNum">     244 </span>            :               : _Options
<span class="lineNum">     245 </span>            :     };
<span class="lineNum">     246 </span>            :   public:
<span class="lineNum">     247 </span>            :     typedef Matrix&lt;_Scalar, _Rows, _Cols, Options, _MaxRows, _MaxCols&gt; type;
<span class="lineNum">     248 </span>            : };
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : template&lt;typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols&gt;
<span class="lineNum">     251 </span>            : class compute_matrix_flags
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span>            :     enum { row_major_bit = Options&amp;RowMajor ? RowMajorBit : 0 };
<span class="lineNum">     254 </span>            :   public:
<span class="lineNum">     255 </span>            :     // FIXME currently we still have to handle DirectAccessBit at the expression level to handle DenseCoeffsBase&lt;&gt;
<span class="lineNum">     256 </span>            :     // and then propagate this information to the evaluator's flags.
<span class="lineNum">     257 </span>            :     // However, I (Gael) think that DirectAccessBit should only matter at the evaluation stage.
<span class="lineNum">     258 </span>            :     enum { ret = DirectAccessBit | LvalueBit | NestByRefBit | row_major_bit };
<span class="lineNum">     259 </span>            : };
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : template&lt;int _Rows, int _Cols&gt; struct size_at_compile_time
<span class="lineNum">     262 </span>            : {
<span class="lineNum">     263 </span>            :   enum { ret = (_Rows==Dynamic || _Cols==Dynamic) ? Dynamic : _Rows * _Cols };
<span class="lineNum">     264 </span>            : };
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : template&lt;typename XprType&gt; struct size_of_xpr_at_compile_time
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span>            :   enum { ret = size_at_compile_time&lt;traits&lt;XprType&gt;::RowsAtCompileTime,traits&lt;XprType&gt;::ColsAtCompileTime&gt;::ret };
<span class="lineNum">     269 </span>            : };
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* plain_matrix_type : the difference from eval is that plain_matrix_type is always a plain matrix type,
<span class="lineNum">     272 </span>            :  * whereas eval is a const reference in the case of a matrix
<span class="lineNum">     273 </span>            :  */
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : template&lt;typename T, typename StorageKind = typename traits&lt;T&gt;::StorageKind&gt; struct plain_matrix_type;
<span class="lineNum">     276 </span>            : template&lt;typename T, typename BaseClassType, int Flags&gt; struct plain_matrix_type_dense;
<span class="lineNum">     277 </span>            : template&lt;typename T&gt; struct plain_matrix_type&lt;T,Dense&gt;
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span>            :   typedef typename plain_matrix_type_dense&lt;T,typename traits&lt;T&gt;::XprKind, traits&lt;T&gt;::Flags&gt;::type type;
<span class="lineNum">     280 </span>            : };
<span class="lineNum">     281 </span>            : template&lt;typename T&gt; struct plain_matrix_type&lt;T,DiagonalShape&gt;
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span>            :   typedef typename T::PlainObject type;
<span class="lineNum">     284 </span>            : };
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : template&lt;typename T, int Flags&gt; struct plain_matrix_type_dense&lt;T,MatrixXpr,Flags&gt;
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span>            :   typedef Matrix&lt;typename traits&lt;T&gt;::Scalar,
<span class="lineNum">     289 </span>            :                 traits&lt;T&gt;::RowsAtCompileTime,
<span class="lineNum">     290 </span>            :                 traits&lt;T&gt;::ColsAtCompileTime,
<span class="lineNum">     291 </span>            :                 AutoAlign | (Flags&amp;RowMajorBit ? RowMajor : ColMajor),
<span class="lineNum">     292 </span>            :                 traits&lt;T&gt;::MaxRowsAtCompileTime,
<span class="lineNum">     293 </span>            :                 traits&lt;T&gt;::MaxColsAtCompileTime
<span class="lineNum">     294 </span>            :           &gt; type;
<span class="lineNum">     295 </span>            : };
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : template&lt;typename T, int Flags&gt; struct plain_matrix_type_dense&lt;T,ArrayXpr,Flags&gt;
<span class="lineNum">     298 </span>            : {
<span class="lineNum">     299 </span>            :   typedef Array&lt;typename traits&lt;T&gt;::Scalar,
<span class="lineNum">     300 </span>            :                 traits&lt;T&gt;::RowsAtCompileTime,
<span class="lineNum">     301 </span>            :                 traits&lt;T&gt;::ColsAtCompileTime,
<span class="lineNum">     302 </span>            :                 AutoAlign | (Flags&amp;RowMajorBit ? RowMajor : ColMajor),
<span class="lineNum">     303 </span>            :                 traits&lt;T&gt;::MaxRowsAtCompileTime,
<span class="lineNum">     304 </span>            :                 traits&lt;T&gt;::MaxColsAtCompileTime
<span class="lineNum">     305 </span>            :           &gt; type;
<span class="lineNum">     306 </span>            : };
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : /* eval : the return type of eval(). For matrices, this is just a const reference
<span class="lineNum">     309 </span>            :  * in order to avoid a useless copy
<span class="lineNum">     310 </span>            :  */
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : template&lt;typename T, typename StorageKind = typename traits&lt;T&gt;::StorageKind&gt; struct eval;
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : template&lt;typename T&gt; struct eval&lt;T,Dense&gt;
<span class="lineNum">     315 </span>            : {
<span class="lineNum">     316 </span>            :   typedef typename plain_matrix_type&lt;T&gt;::type type;
<span class="lineNum">     317 </span>            : //   typedef typename T::PlainObject type;
<span class="lineNum">     318 </span>            : //   typedef T::Matrix&lt;typename traits&lt;T&gt;::Scalar,
<span class="lineNum">     319 </span>            : //                 traits&lt;T&gt;::RowsAtCompileTime,
<span class="lineNum">     320 </span>            : //                 traits&lt;T&gt;::ColsAtCompileTime,
<span class="lineNum">     321 </span>            : //                 AutoAlign | (traits&lt;T&gt;::Flags&amp;RowMajorBit ? RowMajor : ColMajor),
<span class="lineNum">     322 </span>            : //                 traits&lt;T&gt;::MaxRowsAtCompileTime,
<span class="lineNum">     323 </span>            : //                 traits&lt;T&gt;::MaxColsAtCompileTime
<span class="lineNum">     324 </span>            : //           &gt; type;
<span class="lineNum">     325 </span>            : };
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : template&lt;typename T&gt; struct eval&lt;T,DiagonalShape&gt;
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :   typedef typename plain_matrix_type&lt;T&gt;::type type;
<span class="lineNum">     330 </span>            : };
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : // for matrices, no need to evaluate, just use a const reference to avoid a useless copy
<span class="lineNum">     333 </span>            : template&lt;typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt;
<span class="lineNum">     334 </span>            : struct eval&lt;Matrix&lt;_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols&gt;, Dense&gt;
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span>            :   typedef const Matrix&lt;_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols&gt;&amp; type;
<span class="lineNum">     337 </span>            : };
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : template&lt;typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt;
<span class="lineNum">     340 </span>            : struct eval&lt;Array&lt;_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols&gt;, Dense&gt;
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span>            :   typedef const Array&lt;_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols&gt;&amp; type;
<span class="lineNum">     343 </span>            : };
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : /* similar to plain_matrix_type, but using the evaluator's Flags */
<span class="lineNum">     347 </span>            : template&lt;typename T, typename StorageKind = typename traits&lt;T&gt;::StorageKind&gt; struct plain_object_eval;
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : template&lt;typename T&gt;
<span class="lineNum">     350 </span>            : struct plain_object_eval&lt;T,Dense&gt;
<span class="lineNum">     351 </span>            : {
<span class="lineNum">     352 </span>            :   typedef typename plain_matrix_type_dense&lt;T,typename traits&lt;T&gt;::XprKind, evaluator&lt;T&gt;::Flags&gt;::type type;
<span class="lineNum">     353 </span>            : };
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : /* plain_matrix_type_column_major : same as plain_matrix_type but guaranteed to be column-major
<span class="lineNum">     357 </span>            :  */
<span class="lineNum">     358 </span>            : template&lt;typename T&gt; struct plain_matrix_type_column_major
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span>            :   enum { Rows = traits&lt;T&gt;::RowsAtCompileTime,
<span class="lineNum">     361 </span>            :          Cols = traits&lt;T&gt;::ColsAtCompileTime,
<span class="lineNum">     362 </span>            :          MaxRows = traits&lt;T&gt;::MaxRowsAtCompileTime,
<span class="lineNum">     363 </span>            :          MaxCols = traits&lt;T&gt;::MaxColsAtCompileTime
<span class="lineNum">     364 </span>            :   };
<span class="lineNum">     365 </span>            :   typedef Matrix&lt;typename traits&lt;T&gt;::Scalar,
<span class="lineNum">     366 </span>            :                 Rows,
<span class="lineNum">     367 </span>            :                 Cols,
<span class="lineNum">     368 </span>            :                 (MaxRows==1&amp;&amp;MaxCols!=1) ? RowMajor : ColMajor,
<span class="lineNum">     369 </span>            :                 MaxRows,
<span class="lineNum">     370 </span>            :                 MaxCols
<span class="lineNum">     371 </span>            :           &gt; type;
<span class="lineNum">     372 </span>            : };
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : /* plain_matrix_type_row_major : same as plain_matrix_type but guaranteed to be row-major
<span class="lineNum">     375 </span>            :  */
<span class="lineNum">     376 </span>            : template&lt;typename T&gt; struct plain_matrix_type_row_major
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span>            :   enum { Rows = traits&lt;T&gt;::RowsAtCompileTime,
<span class="lineNum">     379 </span>            :          Cols = traits&lt;T&gt;::ColsAtCompileTime,
<span class="lineNum">     380 </span>            :          MaxRows = traits&lt;T&gt;::MaxRowsAtCompileTime,
<span class="lineNum">     381 </span>            :          MaxCols = traits&lt;T&gt;::MaxColsAtCompileTime
<span class="lineNum">     382 </span>            :   };
<span class="lineNum">     383 </span>            :   typedef Matrix&lt;typename traits&lt;T&gt;::Scalar,
<span class="lineNum">     384 </span>            :                 Rows,
<span class="lineNum">     385 </span>            :                 Cols,
<span class="lineNum">     386 </span>            :                 (MaxCols==1&amp;&amp;MaxRows!=1) ? RowMajor : ColMajor,
<span class="lineNum">     387 </span>            :                 MaxRows,
<span class="lineNum">     388 </span>            :                 MaxCols
<span class="lineNum">     389 </span>            :           &gt; type;
<span class="lineNum">     390 </span>            : };
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : /** \internal The reference selector for template expressions. The idea is that we don't
<span class="lineNum">     393 </span>            :   * need to use references for expressions since they are light weight proxy
<span class="lineNum">     394 </span>            :   * objects which should generate no copying overhead. */
<span class="lineNum">     395 </span>            : template &lt;typename T&gt;
<span class="lineNum">     396 </span>            : struct ref_selector
<span class="lineNum">     397 </span>            : {
<span class="lineNum">     398 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     399 </span>            :     bool(traits&lt;T&gt;::Flags &amp; NestByRefBit),
<span class="lineNum">     400 </span>            :     T const&amp;,
<span class="lineNum">     401 </span>            :     const T
<span class="lineNum">     402 </span>            :   &gt;::type type;
<span class="lineNum">     403 </span>            :   
<span class="lineNum">     404 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     405 </span>            :     bool(traits&lt;T&gt;::Flags &amp; NestByRefBit),
<span class="lineNum">     406 </span>            :     T &amp;,
<span class="lineNum">     407 </span>            :     T
<span class="lineNum">     408 </span>            :   &gt;::type non_const_type;
<span class="lineNum">     409 </span>            : };
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : /** \internal Adds the const qualifier on the value-type of T2 if and only if T1 is a const type */
<span class="lineNum">     412 </span>            : template&lt;typename T1, typename T2&gt;
<span class="lineNum">     413 </span>            : struct transfer_constness
<span class="lineNum">     414 </span>            : {
<span class="lineNum">     415 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     416 </span>            :     bool(internal::is_const&lt;T1&gt;::value),
<span class="lineNum">     417 </span>            :     typename internal::add_const_on_value_type&lt;T2&gt;::type,
<span class="lineNum">     418 </span>            :     T2
<span class="lineNum">     419 </span>            :   &gt;::type type;
<span class="lineNum">     420 </span>            : };
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : // However, we still need a mechanism to detect whether an expression which is evaluated multiple time
<span class="lineNum">     424 </span>            : // has to be evaluated into a temporary.
<span class="lineNum">     425 </span>            : // That's the purpose of this new nested_eval helper:
<span class="lineNum">     426 </span>            : /** \internal Determines how a given expression should be nested when evaluated multiple times.
<span class="lineNum">     427 </span>            :   * For example, when you do a * (b+c), Eigen will determine how the expression b+c should be
<span class="lineNum">     428 </span>            :   * evaluated into the bigger product expression. The choice is between nesting the expression b+c as-is, or
<span class="lineNum">     429 </span>            :   * evaluating that expression b+c into a temporary variable d, and nest d so that the resulting expression is
<span class="lineNum">     430 </span>            :   * a*d. Evaluating can be beneficial for example if every coefficient access in the resulting expression causes
<span class="lineNum">     431 </span>            :   * many coefficient accesses in the nested expressions -- as is the case with matrix product for example.
<span class="lineNum">     432 </span>            :   *
<span class="lineNum">     433 </span>            :   * \tparam T the type of the expression being nested.
<span class="lineNum">     434 </span>            :   * \tparam n the number of coefficient accesses in the nested expression for each coefficient access in the bigger expression.
<span class="lineNum">     435 </span>            :   * \tparam PlainObject the type of the temporary if needed.
<span class="lineNum">     436 </span>            :   */
<span class="lineNum">     437 </span>            : template&lt;typename T, int n, typename PlainObject = typename plain_object_eval&lt;T&gt;::type&gt; struct nested_eval
<span class="lineNum">     438 </span>            : {
<span class="lineNum">     439 </span>            :   enum {
<span class="lineNum">     440 </span>            :     ScalarReadCost = NumTraits&lt;typename traits&lt;T&gt;::Scalar&gt;::ReadCost,
<span class="lineNum">     441 </span>            :     CoeffReadCost = evaluator&lt;T&gt;::CoeffReadCost,  // NOTE What if an evaluator evaluate itself into a tempory?
<span class="lineNum">     442 </span>            :                                                   //      Then CoeffReadCost will be small (e.g., 1) but we still have to evaluate, especially if n&gt;1.
<span class="lineNum">     443 </span>            :                                                   //      This situation is already taken care by the EvalBeforeNestingBit flag, which is turned ON
<span class="lineNum">     444 </span>            :                                                   //      for all evaluator creating a temporary. This flag is then propagated by the parent evaluators.
<span class="lineNum">     445 </span>            :                                                   //      Another solution could be to count the number of temps?
<span class="lineNum">     446 </span>            :     NAsInteger = n == Dynamic ? HugeCost : n,
<span class="lineNum">     447 </span>            :     CostEval   = (NAsInteger+1) * ScalarReadCost + CoeffReadCost,
<span class="lineNum">     448 </span>            :     CostNoEval = NAsInteger * CoeffReadCost,
<span class="lineNum">     449 </span>            :     Evaluate = (int(evaluator&lt;T&gt;::Flags) &amp; EvalBeforeNestingBit) || (int(CostEval) &lt; int(CostNoEval))
<span class="lineNum">     450 </span>            :   };
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   typedef typename conditional&lt;Evaluate, PlainObject, typename ref_selector&lt;T&gt;::type&gt;::type type;
<span class="lineNum">     453 </span>            : };
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : template&lt;typename T&gt;
<span class="lineNum">     456 </span>            : EIGEN_DEVICE_FUNC
<span class="lineNum">     457 </span>            : inline T* const_cast_ptr(const T* ptr)
<span class="lineNum">     458 </span>            : {
<span class="lineNum">     459 </span>            :   return const_cast&lt;T*&gt;(ptr);
<span class="lineNum">     460 </span>            : }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : template&lt;typename Derived, typename XprKind = typename traits&lt;Derived&gt;::XprKind&gt;
<span class="lineNum">     463 </span>            : struct dense_xpr_base
<span class="lineNum">     464 </span>            : {
<span class="lineNum">     465 </span>            :   /* dense_xpr_base should only ever be used on dense expressions, thus falling either into the MatrixXpr or into the ArrayXpr cases */
<span class="lineNum">     466 </span>            : };
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : template&lt;typename Derived&gt;
<span class="lineNum">     469 </span>            : struct dense_xpr_base&lt;Derived, MatrixXpr&gt;
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span>            :   typedef MatrixBase&lt;Derived&gt; type;
<span class="lineNum">     472 </span>            : };
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : template&lt;typename Derived&gt;
<span class="lineNum">     475 </span>            : struct dense_xpr_base&lt;Derived, ArrayXpr&gt;
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span>            :   typedef ArrayBase&lt;Derived&gt; type;
<span class="lineNum">     478 </span>            : };
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : template&lt;typename Derived, typename XprKind = typename traits&lt;Derived&gt;::XprKind, typename StorageKind = typename traits&lt;Derived&gt;::StorageKind&gt;
<span class="lineNum">     481 </span>            : struct generic_xpr_base;
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : template&lt;typename Derived, typename XprKind&gt;
<span class="lineNum">     484 </span>            : struct generic_xpr_base&lt;Derived, XprKind, Dense&gt;
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span>            :   typedef typename dense_xpr_base&lt;Derived,XprKind&gt;::type type;
<span class="lineNum">     487 </span>            : };
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : template&lt;typename XprType, typename CastType&gt; struct cast_return_type
<span class="lineNum">     490 </span>            : {
<span class="lineNum">     491 </span>            :   typedef typename XprType::Scalar CurrentScalarType;
<span class="lineNum">     492 </span>            :   typedef typename remove_all&lt;CastType&gt;::type _CastType;
<span class="lineNum">     493 </span>            :   typedef typename _CastType::Scalar NewScalarType;
<span class="lineNum">     494 </span>            :   typedef typename conditional&lt;is_same&lt;CurrentScalarType,NewScalarType&gt;::value,
<span class="lineNum">     495 </span>            :                               const XprType&amp;,CastType&gt;::type type;
<span class="lineNum">     496 </span>            : };
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : template &lt;typename A, typename B&gt; struct promote_storage_type;
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : template &lt;typename A&gt; struct promote_storage_type&lt;A,A&gt;
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span>            :   typedef A ret;
<span class="lineNum">     503 </span>            : };
<span class="lineNum">     504 </span>            : template &lt;typename A&gt; struct promote_storage_type&lt;A, const A&gt;
<span class="lineNum">     505 </span>            : {
<span class="lineNum">     506 </span>            :   typedef A ret;
<span class="lineNum">     507 </span>            : };
<span class="lineNum">     508 </span>            : template &lt;typename A&gt; struct promote_storage_type&lt;const A, A&gt;
<span class="lineNum">     509 </span>            : {
<span class="lineNum">     510 </span>            :   typedef A ret;
<span class="lineNum">     511 </span>            : };
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : /** \internal Specify the &quot;storage kind&quot; of applying a coefficient-wise
<span class="lineNum">     514 </span>            :   * binary operations between two expressions of kinds A and B respectively.
<span class="lineNum">     515 </span>            :   * The template parameter Functor permits to specialize the resulting storage kind wrt to
<span class="lineNum">     516 </span>            :   * the functor.
<span class="lineNum">     517 </span>            :   * The default rules are as follows:
<span class="lineNum">     518 </span>            :   * \code
<span class="lineNum">     519 </span>            :   * A      op A      -&gt; A
<span class="lineNum">     520 </span>            :   * A      op dense  -&gt; dense
<span class="lineNum">     521 </span>            :   * dense  op B      -&gt; dense
<span class="lineNum">     522 </span>            :   * sparse op dense  -&gt; sparse
<span class="lineNum">     523 </span>            :   * dense  op sparse -&gt; sparse
<span class="lineNum">     524 </span>            :   * \endcode
<span class="lineNum">     525 </span>            :   */
<span class="lineNum">     526 </span>            : template &lt;typename A, typename B, typename Functor&gt; struct cwise_promote_storage_type;
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : template &lt;typename A, typename Functor&gt;                   struct cwise_promote_storage_type&lt;A,A,Functor&gt;                                      { typedef A      ret; };
<span class="lineNum">     529 </span>            : template &lt;typename Functor&gt;                               struct cwise_promote_storage_type&lt;Dense,Dense,Functor&gt;                              { typedef Dense  ret; };
<span class="lineNum">     530 </span>            : template &lt;typename A, typename Functor&gt;                   struct cwise_promote_storage_type&lt;A,Dense,Functor&gt;                                  { typedef Dense  ret; };
<span class="lineNum">     531 </span>            : template &lt;typename B, typename Functor&gt;                   struct cwise_promote_storage_type&lt;Dense,B,Functor&gt;                                  { typedef Dense  ret; };
<span class="lineNum">     532 </span>            : template &lt;typename Functor&gt;                               struct cwise_promote_storage_type&lt;Sparse,Dense,Functor&gt;                             { typedef Sparse ret; };
<span class="lineNum">     533 </span>            : template &lt;typename Functor&gt;                               struct cwise_promote_storage_type&lt;Dense,Sparse,Functor&gt;                             { typedef Sparse ret; };
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            : template &lt;typename LhsKind, typename RhsKind, int LhsOrder, int RhsOrder&gt; struct cwise_promote_storage_order {
<span class="lineNum">     536 </span>            :   enum { value = LhsOrder };
<span class="lineNum">     537 </span>            : };
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : template &lt;typename LhsKind, int LhsOrder, int RhsOrder&gt;   struct cwise_promote_storage_order&lt;LhsKind,Sparse,LhsOrder,RhsOrder&gt;                { enum { value = RhsOrder }; };
<span class="lineNum">     540 </span>            : template &lt;typename RhsKind, int LhsOrder, int RhsOrder&gt;   struct cwise_promote_storage_order&lt;Sparse,RhsKind,LhsOrder,RhsOrder&gt;                { enum { value = LhsOrder }; };
<span class="lineNum">     541 </span>            : template &lt;int Order&gt;                                      struct cwise_promote_storage_order&lt;Sparse,Sparse,Order,Order&gt;                       { enum { value = Order }; };
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : /** \internal Specify the &quot;storage kind&quot; of multiplying an expression of kind A with kind B.
<span class="lineNum">     545 </span>            :   * The template parameter ProductTag permits to specialize the resulting storage kind wrt to
<span class="lineNum">     546 </span>            :   * some compile-time properties of the product: GemmProduct, GemvProduct, OuterProduct, InnerProduct.
<span class="lineNum">     547 </span>            :   * The default rules are as follows:
<span class="lineNum">     548 </span>            :   * \code
<span class="lineNum">     549 </span>            :   *  K * K            -&gt; K
<span class="lineNum">     550 </span>            :   *  dense * K        -&gt; dense
<span class="lineNum">     551 </span>            :   *  K * dense        -&gt; dense
<span class="lineNum">     552 </span>            :   *  diag * K         -&gt; K
<span class="lineNum">     553 </span>            :   *  K * diag         -&gt; K
<span class="lineNum">     554 </span>            :   *  Perm * K         -&gt; K
<span class="lineNum">     555 </span>            :   * K * Perm          -&gt; K
<span class="lineNum">     556 </span>            :   * \endcode
<span class="lineNum">     557 </span>            :   */
<span class="lineNum">     558 </span>            : template &lt;typename A, typename B, int ProductTag&gt; struct product_promote_storage_type;
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : template &lt;typename A, int ProductTag&gt; struct product_promote_storage_type&lt;A,                  A,                  ProductTag&gt; { typedef A     ret;};
<span class="lineNum">     561 </span>            : template &lt;int ProductTag&gt;             struct product_promote_storage_type&lt;Dense,              Dense,              ProductTag&gt; { typedef Dense ret;};
<span class="lineNum">     562 </span>            : template &lt;typename A, int ProductTag&gt; struct product_promote_storage_type&lt;A,                  Dense,              ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     563 </span>            : template &lt;typename B, int ProductTag&gt; struct product_promote_storage_type&lt;Dense,              B,                  ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : template &lt;typename A, int ProductTag&gt; struct product_promote_storage_type&lt;A,                  DiagonalShape,      ProductTag&gt; { typedef A ret; };
<span class="lineNum">     566 </span>            : template &lt;typename B, int ProductTag&gt; struct product_promote_storage_type&lt;DiagonalShape,      B,                  ProductTag&gt; { typedef B ret; };
<span class="lineNum">     567 </span>            : template &lt;int ProductTag&gt;             struct product_promote_storage_type&lt;Dense,              DiagonalShape,      ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     568 </span>            : template &lt;int ProductTag&gt;             struct product_promote_storage_type&lt;DiagonalShape,      Dense,              ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : template &lt;typename A, int ProductTag&gt; struct product_promote_storage_type&lt;A,                  PermutationStorage, ProductTag&gt; { typedef A ret; };
<span class="lineNum">     571 </span>            : template &lt;typename B, int ProductTag&gt; struct product_promote_storage_type&lt;PermutationStorage, B,                  ProductTag&gt; { typedef B ret; };
<span class="lineNum">     572 </span>            : template &lt;int ProductTag&gt;             struct product_promote_storage_type&lt;Dense,              PermutationStorage, ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     573 </span>            : template &lt;int ProductTag&gt;             struct product_promote_storage_type&lt;PermutationStorage, Dense,              ProductTag&gt; { typedef Dense ret; };
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : /** \internal gives the plain matrix or array type to store a row/column/diagonal of a matrix type.
<span class="lineNum">     576 </span>            :   * \tparam Scalar optional parameter allowing to pass a different scalar type than the one of the MatrixType.
<span class="lineNum">     577 </span>            :   */
<span class="lineNum">     578 </span>            : template&lt;typename ExpressionType, typename Scalar = typename ExpressionType::Scalar&gt;
<span class="lineNum">     579 </span>            : struct plain_row_type
<span class="lineNum">     580 </span>            : {
<span class="lineNum">     581 </span>            :   typedef Matrix&lt;Scalar, 1, ExpressionType::ColsAtCompileTime,
<span class="lineNum">     582 </span>            :                  ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime&gt; MatrixRowType;
<span class="lineNum">     583 </span>            :   typedef Array&lt;Scalar, 1, ExpressionType::ColsAtCompileTime,
<span class="lineNum">     584 </span>            :                  ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime&gt; ArrayRowType;
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     587 </span>            :     is_same&lt; typename traits&lt;ExpressionType&gt;::XprKind, MatrixXpr &gt;::value,
<span class="lineNum">     588 </span>            :     MatrixRowType,
<span class="lineNum">     589 </span>            :     ArrayRowType 
<span class="lineNum">     590 </span>            :   &gt;::type type;
<span class="lineNum">     591 </span>            : };
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : template&lt;typename ExpressionType, typename Scalar = typename ExpressionType::Scalar&gt;
<span class="lineNum">     594 </span>            : struct plain_col_type
<span class="lineNum">     595 </span>            : {
<span class="lineNum">     596 </span>            :   typedef Matrix&lt;Scalar, ExpressionType::RowsAtCompileTime, 1,
<span class="lineNum">     597 </span>            :                  ExpressionType::PlainObject::Options &amp; ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1&gt; MatrixColType;
<span class="lineNum">     598 </span>            :   typedef Array&lt;Scalar, ExpressionType::RowsAtCompileTime, 1,
<span class="lineNum">     599 </span>            :                  ExpressionType::PlainObject::Options &amp; ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1&gt; ArrayColType;
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     602 </span>            :     is_same&lt; typename traits&lt;ExpressionType&gt;::XprKind, MatrixXpr &gt;::value,
<span class="lineNum">     603 </span>            :     MatrixColType,
<span class="lineNum">     604 </span>            :     ArrayColType 
<span class="lineNum">     605 </span>            :   &gt;::type type;
<span class="lineNum">     606 </span>            : };
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : template&lt;typename ExpressionType, typename Scalar = typename ExpressionType::Scalar&gt;
<span class="lineNum">     609 </span>            : struct plain_diag_type
<span class="lineNum">     610 </span>            : {
<span class="lineNum">     611 </span>            :   enum { diag_size = EIGEN_SIZE_MIN_PREFER_DYNAMIC(ExpressionType::RowsAtCompileTime, ExpressionType::ColsAtCompileTime),
<span class="lineNum">     612 </span>            :          max_diag_size = EIGEN_SIZE_MIN_PREFER_FIXED(ExpressionType::MaxRowsAtCompileTime, ExpressionType::MaxColsAtCompileTime)
<span class="lineNum">     613 </span>            :   };
<span class="lineNum">     614 </span>            :   typedef Matrix&lt;Scalar, diag_size, 1, ExpressionType::PlainObject::Options &amp; ~RowMajor, max_diag_size, 1&gt; MatrixDiagType;
<span class="lineNum">     615 </span>            :   typedef Array&lt;Scalar, diag_size, 1, ExpressionType::PlainObject::Options &amp; ~RowMajor, max_diag_size, 1&gt; ArrayDiagType;
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :   typedef typename conditional&lt;
<span class="lineNum">     618 </span>            :     is_same&lt; typename traits&lt;ExpressionType&gt;::XprKind, MatrixXpr &gt;::value,
<span class="lineNum">     619 </span>            :     MatrixDiagType,
<span class="lineNum">     620 </span>            :     ArrayDiagType 
<span class="lineNum">     621 </span>            :   &gt;::type type;
<span class="lineNum">     622 </span>            : };
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : template&lt;typename Expr,typename Scalar = typename Expr::Scalar&gt;
<span class="lineNum">     625 </span>            : struct plain_constant_type
<span class="lineNum">     626 </span>            : {
<span class="lineNum">     627 </span>            :   enum { Options = (traits&lt;Expr&gt;::Flags&amp;RowMajorBit)?RowMajor:0 };
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   typedef Array&lt;Scalar,  traits&lt;Expr&gt;::RowsAtCompileTime,   traits&lt;Expr&gt;::ColsAtCompileTime,
<span class="lineNum">     630 </span>            :                 Options, traits&lt;Expr&gt;::MaxRowsAtCompileTime,traits&lt;Expr&gt;::MaxColsAtCompileTime&gt; array_type;
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :   typedef Matrix&lt;Scalar,  traits&lt;Expr&gt;::RowsAtCompileTime,   traits&lt;Expr&gt;::ColsAtCompileTime,
<span class="lineNum">     633 </span>            :                  Options, traits&lt;Expr&gt;::MaxRowsAtCompileTime,traits&lt;Expr&gt;::MaxColsAtCompileTime&gt; matrix_type;
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :   typedef CwiseNullaryOp&lt;scalar_constant_op&lt;Scalar&gt;, const typename conditional&lt;is_same&lt; typename traits&lt;Expr&gt;::XprKind, MatrixXpr &gt;::value, matrix_type, array_type&gt;::type &gt; type;
<span class="lineNum">     636 </span>            : };
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            : template&lt;typename ExpressionType&gt;
<span class="lineNum">     639 </span>            : struct is_lvalue
<span class="lineNum">     640 </span>            : {
<span class="lineNum">     641 </span>            :   enum { value = (!bool(is_const&lt;ExpressionType&gt;::value)) &amp;&amp;
<span class="lineNum">     642 </span>            :                  bool(traits&lt;ExpressionType&gt;::Flags &amp; LvalueBit) };
<span class="lineNum">     643 </span>            : };
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : template&lt;typename T&gt; struct is_diagonal
<span class="lineNum">     646 </span>            : { enum { ret = false }; };
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : template&lt;typename T&gt; struct is_diagonal&lt;DiagonalBase&lt;T&gt; &gt;
<span class="lineNum">     649 </span>            : { enum { ret = true }; };
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : template&lt;typename T&gt; struct is_diagonal&lt;DiagonalWrapper&lt;T&gt; &gt;
<span class="lineNum">     652 </span>            : { enum { ret = true }; };
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : template&lt;typename T, int S&gt; struct is_diagonal&lt;DiagonalMatrix&lt;T,S&gt; &gt;
<span class="lineNum">     655 </span>            : { enum { ret = true }; };
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            : template&lt;typename S1, typename S2&gt; struct glue_shapes;
<span class="lineNum">     658 </span>            : template&lt;&gt; struct glue_shapes&lt;DenseShape,TriangularShape&gt; { typedef TriangularShape type;  };
<a name="659"><span class="lineNum">     659 </span>            : </a>
<span class="lineNum">     660 </span>            : template&lt;typename T1, typename T2&gt;
<span class="lineNum">     661 </span><span class="lineCov">        940 : bool is_same_dense(const T1 &amp;mat1, const T2 &amp;mat2, typename enable_if&lt;has_direct_access&lt;T1&gt;::ret&amp;&amp;has_direct_access&lt;T2&gt;::ret, T1&gt;::type * = 0)</span>
<span class="lineNum">     662 </span>            : {
<span class="lineNum">     663 </span><span class="lineCov">        940 :   return (mat1.data()==mat2.data()) &amp;&amp; (mat1.innerStride()==mat2.innerStride()) &amp;&amp; (mat1.outerStride()==mat2.outerStride());</span>
<span class="lineNum">     664 </span>            : }
<a name="665"><span class="lineNum">     665 </span>            : </a>
<span class="lineNum">     666 </span>            : template&lt;typename T1, typename T2&gt;
<span class="lineNum">     667 </span><span class="lineNoCov">          0 : bool is_same_dense(const T1 &amp;, const T2 &amp;, typename enable_if&lt;!(has_direct_access&lt;T1&gt;::ret&amp;&amp;has_direct_access&lt;T2&gt;::ret), T1&gt;::type * = 0)</span>
<span class="lineNum">     668 </span>            : {
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     670 </span>            : }
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : // Internal helper defining the cost of a scalar division for the type T.
<span class="lineNum">     673 </span>            : // The default heuristic can be specialized for each scalar type and architecture.
<span class="lineNum">     674 </span>            : template&lt;typename T,bool Vectorized=false,typename EnaleIf = void&gt;
<span class="lineNum">     675 </span>            : struct scalar_div_cost {
<span class="lineNum">     676 </span>            :   enum { value = 8*NumTraits&lt;T&gt;::MulCost };
<span class="lineNum">     677 </span>            : };
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : template&lt;typename T,bool Vectorized&gt;
<span class="lineNum">     680 </span>            : struct scalar_div_cost&lt;std::complex&lt;T&gt;, Vectorized&gt; {
<span class="lineNum">     681 </span>            :   enum { value = 2*scalar_div_cost&lt;T&gt;::value
<span class="lineNum">     682 </span>            :                + 6*NumTraits&lt;T&gt;::MulCost
<span class="lineNum">     683 </span>            :                + 3*NumTraits&lt;T&gt;::AddCost
<span class="lineNum">     684 </span>            :   };
<span class="lineNum">     685 </span>            : };
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            : template&lt;bool Vectorized&gt;
<span class="lineNum">     689 </span>            : struct scalar_div_cost&lt;signed long,Vectorized,typename conditional&lt;sizeof(long)==8,void,false_type&gt;::type&gt; { enum { value = 24 }; };
<span class="lineNum">     690 </span>            : template&lt;bool Vectorized&gt;
<span class="lineNum">     691 </span>            : struct scalar_div_cost&lt;unsigned long,Vectorized,typename conditional&lt;sizeof(long)==8,void,false_type&gt;::type&gt; { enum { value = 21 }; };
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : #ifdef EIGEN_DEBUG_ASSIGN
<span class="lineNum">     695 </span>            : std::string demangle_traversal(int t)
<span class="lineNum">     696 </span>            : {
<span class="lineNum">     697 </span>            :   if(t==DefaultTraversal) return &quot;DefaultTraversal&quot;;
<span class="lineNum">     698 </span>            :   if(t==LinearTraversal) return &quot;LinearTraversal&quot;;
<span class="lineNum">     699 </span>            :   if(t==InnerVectorizedTraversal) return &quot;InnerVectorizedTraversal&quot;;
<span class="lineNum">     700 </span>            :   if(t==LinearVectorizedTraversal) return &quot;LinearVectorizedTraversal&quot;;
<span class="lineNum">     701 </span>            :   if(t==SliceVectorizedTraversal) return &quot;SliceVectorizedTraversal&quot;;
<span class="lineNum">     702 </span>            :   return &quot;?&quot;;
<span class="lineNum">     703 </span>            : }
<span class="lineNum">     704 </span>            : std::string demangle_unrolling(int t)
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span>            :   if(t==NoUnrolling) return &quot;NoUnrolling&quot;;
<span class="lineNum">     707 </span>            :   if(t==InnerUnrolling) return &quot;InnerUnrolling&quot;;
<span class="lineNum">     708 </span>            :   if(t==CompleteUnrolling) return &quot;CompleteUnrolling&quot;;
<span class="lineNum">     709 </span>            :   return &quot;?&quot;;
<span class="lineNum">     710 </span>            : }
<span class="lineNum">     711 </span>            : std::string demangle_flags(int f)
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span>            :   std::string res;
<span class="lineNum">     714 </span>            :   if(f&amp;RowMajorBit)                 res += &quot; | RowMajor&quot;;
<span class="lineNum">     715 </span>            :   if(f&amp;PacketAccessBit)             res += &quot; | Packet&quot;;
<span class="lineNum">     716 </span>            :   if(f&amp;LinearAccessBit)             res += &quot; | Linear&quot;;
<span class="lineNum">     717 </span>            :   if(f&amp;LvalueBit)                   res += &quot; | Lvalue&quot;;
<span class="lineNum">     718 </span>            :   if(f&amp;DirectAccessBit)             res += &quot; | Direct&quot;;
<span class="lineNum">     719 </span>            :   if(f&amp;NestByRefBit)                res += &quot; | NestByRef&quot;;
<span class="lineNum">     720 </span>            :   if(f&amp;NoPreferredStorageOrderBit)  res += &quot; | NoPreferredStorageOrderBit&quot;;
<span class="lineNum">     721 </span>            :   
<span class="lineNum">     722 </span>            :   return res;
<span class="lineNum">     723 </span>            : }
<span class="lineNum">     724 </span>            : #endif
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : } // end namespace internal
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : /** \class ScalarBinaryOpTraits
<span class="lineNum">     730 </span>            :   * \ingroup Core_Module
<span class="lineNum">     731 </span>            :   *
<span class="lineNum">     732 </span>            :   * \brief Determines whether the given binary operation of two numeric types is allowed and what the scalar return type is.
<span class="lineNum">     733 </span>            :   *
<span class="lineNum">     734 </span>            :   * This class permits to control the scalar return type of any binary operation performed on two different scalar types through (partial) template specializations.
<span class="lineNum">     735 </span>            :   *
<span class="lineNum">     736 </span>            :   * For instance, let \c U1, \c U2 and \c U3 be three user defined scalar types for which most operations between instances of \c U1 and \c U2 returns an \c U3.
<span class="lineNum">     737 </span>            :   * You can let %Eigen knows that by defining:
<span class="lineNum">     738 </span>            :     \code
<span class="lineNum">     739 </span>            :     template&lt;typename BinaryOp&gt;
<span class="lineNum">     740 </span>            :     struct ScalarBinaryOpTraits&lt;U1,U2,BinaryOp&gt; { typedef U3 ReturnType;  };
<span class="lineNum">     741 </span>            :     template&lt;typename BinaryOp&gt;
<span class="lineNum">     742 </span>            :     struct ScalarBinaryOpTraits&lt;U2,U1,BinaryOp&gt; { typedef U3 ReturnType;  };
<span class="lineNum">     743 </span>            :     \endcode
<span class="lineNum">     744 </span>            :   * You can then explicitly disable some particular operations to get more explicit error messages:
<span class="lineNum">     745 </span>            :     \code
<span class="lineNum">     746 </span>            :     template&lt;&gt;
<span class="lineNum">     747 </span>            :     struct ScalarBinaryOpTraits&lt;U1,U2,internal::scalar_max_op&lt;U1,U2&gt; &gt; {};
<span class="lineNum">     748 </span>            :     \endcode
<span class="lineNum">     749 </span>            :   * Or customize the return type for individual operation:
<span class="lineNum">     750 </span>            :     \code
<span class="lineNum">     751 </span>            :     template&lt;&gt;
<span class="lineNum">     752 </span>            :     struct ScalarBinaryOpTraits&lt;U1,U2,internal::scalar_sum_op&lt;U1,U2&gt; &gt; { typedef U1 ReturnType; };
<span class="lineNum">     753 </span>            :     \endcode
<span class="lineNum">     754 </span>            :   *
<span class="lineNum">     755 </span>            :   * By default, the following generic combinations are supported:
<span class="lineNum">     756 </span>            :   &lt;table class=&quot;manual&quot;&gt;
<span class="lineNum">     757 </span>            :   &lt;tr&gt;&lt;th&gt;ScalarA&lt;/th&gt;&lt;th&gt;ScalarB&lt;/th&gt;&lt;th&gt;BinaryOp&lt;/th&gt;&lt;th&gt;ReturnType&lt;/th&gt;&lt;th&gt;Note&lt;/th&gt;&lt;/tr&gt;
<span class="lineNum">     758 </span>            :   &lt;tr            &gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;\c * &lt;/td&gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
<span class="lineNum">     759 </span>            :   &lt;tr class=&quot;alt&quot;&gt;&lt;td&gt;\c NumTraits&lt;T&gt;::Real &lt;/td&gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;\c * &lt;/td&gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;Only if \c NumTraits&lt;T&gt;::IsComplex &lt;/td&gt;&lt;/tr&gt;
<span class="lineNum">     760 </span>            :   &lt;tr            &gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;\c NumTraits&lt;T&gt;::Real &lt;/td&gt;&lt;td&gt;\c * &lt;/td&gt;&lt;td&gt;\c T &lt;/td&gt;&lt;td&gt;Only if \c NumTraits&lt;T&gt;::IsComplex &lt;/td&gt;&lt;/tr&gt;
<span class="lineNum">     761 </span>            :   &lt;/table&gt;
<span class="lineNum">     762 </span>            :   *
<span class="lineNum">     763 </span>            :   * \sa CwiseBinaryOp
<span class="lineNum">     764 </span>            :   */
<span class="lineNum">     765 </span>            : template&lt;typename ScalarA, typename ScalarB, typename BinaryOp=internal::scalar_product_op&lt;ScalarA,ScalarB&gt; &gt;
<span class="lineNum">     766 </span>            : struct ScalarBinaryOpTraits
<span class="lineNum">     767 </span>            : #ifndef EIGEN_PARSED_BY_DOXYGEN
<span class="lineNum">     768 </span>            :   // for backward compatibility, use the hints given by the (deprecated) internal::scalar_product_traits class.
<span class="lineNum">     769 </span>            :   : internal::scalar_product_traits&lt;ScalarA,ScalarB&gt;
<span class="lineNum">     770 </span>            : #endif // EIGEN_PARSED_BY_DOXYGEN
<span class="lineNum">     771 </span>            : {};
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : template&lt;typename T, typename BinaryOp&gt;
<span class="lineNum">     774 </span>            : struct ScalarBinaryOpTraits&lt;T,T,BinaryOp&gt;
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span>            :   typedef T ReturnType;
<span class="lineNum">     777 </span>            : };
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : template &lt;typename T, typename BinaryOp&gt;
<span class="lineNum">     780 </span>            : struct ScalarBinaryOpTraits&lt;T, typename NumTraits&lt;typename internal::enable_if&lt;NumTraits&lt;T&gt;::IsComplex,T&gt;::type&gt;::Real, BinaryOp&gt;
<span class="lineNum">     781 </span>            : {
<span class="lineNum">     782 </span>            :   typedef T ReturnType;
<span class="lineNum">     783 </span>            : };
<span class="lineNum">     784 </span>            : template &lt;typename T, typename BinaryOp&gt;
<span class="lineNum">     785 </span>            : struct ScalarBinaryOpTraits&lt;typename NumTraits&lt;typename internal::enable_if&lt;NumTraits&lt;T&gt;::IsComplex,T&gt;::type&gt;::Real, T, BinaryOp&gt;
<span class="lineNum">     786 </span>            : {
<span class="lineNum">     787 </span>            :   typedef T ReturnType;
<span class="lineNum">     788 </span>            : };
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : // For Matrix * Permutation
<span class="lineNum">     791 </span>            : template&lt;typename T, typename BinaryOp&gt;
<span class="lineNum">     792 </span>            : struct ScalarBinaryOpTraits&lt;T,void,BinaryOp&gt;
<span class="lineNum">     793 </span>            : {
<span class="lineNum">     794 </span>            :   typedef T ReturnType;
<span class="lineNum">     795 </span>            : };
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : // For Permutation * Matrix
<span class="lineNum">     798 </span>            : template&lt;typename T, typename BinaryOp&gt;
<span class="lineNum">     799 </span>            : struct ScalarBinaryOpTraits&lt;void,T,BinaryOp&gt;
<span class="lineNum">     800 </span>            : {
<span class="lineNum">     801 </span>            :   typedef T ReturnType;
<span class="lineNum">     802 </span>            : };
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : // for Permutation*Permutation
<span class="lineNum">     805 </span>            : template&lt;typename BinaryOp&gt;
<span class="lineNum">     806 </span>            : struct ScalarBinaryOpTraits&lt;void,void,BinaryOp&gt;
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span>            :   typedef void ReturnType;
<span class="lineNum">     809 </span>            : };
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : // We require Lhs and Rhs to have &quot;compatible&quot; scalar types.
<span class="lineNum">     812 </span>            : // It is tempting to always allow mixing different types but remember that this is often impossible in the vectorized paths.
<span class="lineNum">     813 </span>            : // So allowing mixing different types gives very unexpected errors when enabling vectorization, when the user tries to
<span class="lineNum">     814 </span>            : // add together a float matrix and a double matrix.
<span class="lineNum">     815 </span>            : #define EIGEN_CHECK_BINARY_COMPATIBILIY(BINOP,LHS,RHS) \
<span class="lineNum">     816 </span>            :   EIGEN_STATIC_ASSERT((Eigen::internal::has_ReturnType&lt;ScalarBinaryOpTraits&lt;LHS, RHS,BINOP&gt; &gt;::value), \
<span class="lineNum">     817 </span>            :     YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
<span class="lineNum">     818 </span>            :     
<span class="lineNum">     819 </span>            : } // end namespace Eigen
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            : #endif // EIGEN_XPRHELPER_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
