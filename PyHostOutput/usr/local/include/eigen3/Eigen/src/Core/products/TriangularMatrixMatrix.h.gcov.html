<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PyHost Code Analysis - /usr/local/include/eigen3/Eigen/src/Core/products/TriangularMatrixMatrix.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">usr/local/include/eigen3/Eigen/src/Core/products</a> - TriangularMatrixMatrix.h<span style="font-size: 80%;"> (source / <a href="TriangularMatrixMatrix.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PyHost Code Analysis</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-08-16 17:04:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // This file is part of Eigen, a lightweight C++ template library</a>
<span class="lineNum">       2 </span>            : // for linear algebra.
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : // Copyright (C) 2009 Gael Guennebaud &lt;gael.guennebaud@inria.fr&gt;
<span class="lineNum">       5 </span>            : //
<span class="lineNum">       6 </span>            : // This Source Code Form is subject to the terms of the Mozilla
<span class="lineNum">       7 </span>            : // Public License v. 2.0. If a copy of the MPL was not distributed
<span class="lineNum">       8 </span>            : // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #ifndef EIGEN_TRIANGULAR_MATRIX_MATRIX_H
<span class="lineNum">      11 </span>            : #define EIGEN_TRIANGULAR_MATRIX_MATRIX_H
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : namespace Eigen { 
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : namespace internal {
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : // template&lt;typename Scalar, int mr, int StorageOrder, bool Conjugate, int Mode&gt;
<span class="lineNum">      18 </span>            : // struct gemm_pack_lhs_triangular
<span class="lineNum">      19 </span>            : // {
<span class="lineNum">      20 </span>            : //   Matrix&lt;Scalar,mr,mr,
<span class="lineNum">      21 </span>            : //   void operator()(Scalar* blockA, const EIGEN_RESTRICT Scalar* _lhs, int lhsStride, int depth, int rows)
<span class="lineNum">      22 </span>            : //   {
<span class="lineNum">      23 </span>            : //     conj_if&lt;NumTraits&lt;Scalar&gt;::IsComplex &amp;&amp; Conjugate&gt; cj;
<span class="lineNum">      24 </span>            : //     const_blas_data_mapper&lt;Scalar, StorageOrder&gt; lhs(_lhs,lhsStride);
<span class="lineNum">      25 </span>            : //     int count = 0;
<span class="lineNum">      26 </span>            : //     const int peeled_mc = (rows/mr)*mr;
<span class="lineNum">      27 </span>            : //     for(int i=0; i&lt;peeled_mc; i+=mr)
<span class="lineNum">      28 </span>            : //     {
<span class="lineNum">      29 </span>            : //       for(int k=0; k&lt;depth; k++)
<span class="lineNum">      30 </span>            : //         for(int w=0; w&lt;mr; w++)
<span class="lineNum">      31 </span>            : //           blockA[count++] = cj(lhs(i+w, k));
<span class="lineNum">      32 </span>            : //     }
<span class="lineNum">      33 </span>            : //     for(int i=peeled_mc; i&lt;rows; i++)
<span class="lineNum">      34 </span>            : //     {
<span class="lineNum">      35 </span>            : //       for(int k=0; k&lt;depth; k++)
<span class="lineNum">      36 </span>            : //         blockA[count++] = cj(lhs(i, k));
<span class="lineNum">      37 </span>            : //     }
<span class="lineNum">      38 </span>            : //   }
<span class="lineNum">      39 </span>            : // };
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /* Optimized triangular matrix * matrix (_TRMM++) product built on top of
<span class="lineNum">      42 </span>            :  * the general matrix matrix product.
<span class="lineNum">      43 </span>            :  */
<span class="lineNum">      44 </span>            : template &lt;typename Scalar, typename Index,
<span class="lineNum">      45 </span>            :           int Mode, bool LhsIsTriangular,
<span class="lineNum">      46 </span>            :           int LhsStorageOrder, bool ConjugateLhs,
<span class="lineNum">      47 </span>            :           int RhsStorageOrder, bool ConjugateRhs,
<span class="lineNum">      48 </span>            :           int ResStorageOrder, int Version = Specialized&gt;
<span class="lineNum">      49 </span>            : struct product_triangular_matrix_matrix;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : template &lt;typename Scalar, typename Index,
<span class="lineNum">      52 </span>            :           int Mode, bool LhsIsTriangular,
<span class="lineNum">      53 </span>            :           int LhsStorageOrder, bool ConjugateLhs,
<span class="lineNum">      54 </span>            :           int RhsStorageOrder, bool ConjugateRhs, int Version&gt;
<span class="lineNum">      55 </span>            : struct product_triangular_matrix_matrix&lt;Scalar,Index,Mode,LhsIsTriangular,
<span class="lineNum">      56 </span>            :                                            LhsStorageOrder,ConjugateLhs,
<span class="lineNum">      57 </span>            :                                            RhsStorageOrder,ConjugateRhs,RowMajor,Version&gt;
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span>            :   static EIGEN_STRONG_INLINE void run(
<span class="lineNum">      60 </span>            :     Index rows, Index cols, Index depth,
<span class="lineNum">      61 </span>            :     const Scalar* lhs, Index lhsStride,
<span class="lineNum">      62 </span>            :     const Scalar* rhs, Index rhsStride,
<span class="lineNum">      63 </span>            :     Scalar* res,       Index resStride,
<span class="lineNum">      64 </span>            :     const Scalar&amp; alpha, level3_blocking&lt;Scalar,Scalar&gt;&amp; blocking)
<span class="lineNum">      65 </span>            :   {
<span class="lineNum">      66 </span>            :     product_triangular_matrix_matrix&lt;Scalar, Index,
<span class="lineNum">      67 </span>            :       (Mode&amp;(UnitDiag|ZeroDiag)) | ((Mode&amp;Upper) ? Lower : Upper),
<span class="lineNum">      68 </span>            :       (!LhsIsTriangular),
<span class="lineNum">      69 </span>            :       RhsStorageOrder==RowMajor ? ColMajor : RowMajor,
<span class="lineNum">      70 </span>            :       ConjugateRhs,
<span class="lineNum">      71 </span>            :       LhsStorageOrder==RowMajor ? ColMajor : RowMajor,
<span class="lineNum">      72 </span>            :       ConjugateLhs,
<span class="lineNum">      73 </span>            :       ColMajor&gt;
<span class="lineNum">      74 </span>            :       ::run(cols, rows, depth, rhs, rhsStride, lhs, lhsStride, res, resStride, alpha, blocking);
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span>            : };
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : // implements col-major += alpha * op(triangular) * op(general)
<span class="lineNum">      79 </span>            : template &lt;typename Scalar, typename Index, int Mode,
<span class="lineNum">      80 </span>            :           int LhsStorageOrder, bool ConjugateLhs,
<span class="lineNum">      81 </span>            :           int RhsStorageOrder, bool ConjugateRhs, int Version&gt;
<span class="lineNum">      82 </span>            : struct product_triangular_matrix_matrix&lt;Scalar,Index,Mode,true,
<span class="lineNum">      83 </span>            :                                            LhsStorageOrder,ConjugateLhs,
<span class="lineNum">      84 </span>            :                                            RhsStorageOrder,ConjugateRhs,ColMajor,Version&gt;
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span>            :   
<span class="lineNum">      87 </span>            :   typedef gebp_traits&lt;Scalar,Scalar&gt; Traits;
<span class="lineNum">      88 </span>            :   enum {
<span class="lineNum">      89 </span>            :     SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
<span class="lineNum">      90 </span>            :     IsLower = (Mode&amp;Lower) == Lower,
<span class="lineNum">      91 </span>            :     SetDiag = (Mode&amp;(ZeroDiag|UnitDiag)) ? 0 : 1
<span class="lineNum">      92 </span>            :   };
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            :   static EIGEN_DONT_INLINE void run(
<span class="lineNum">      95 </span>            :     Index _rows, Index _cols, Index _depth,
<span class="lineNum">      96 </span>            :     const Scalar* _lhs, Index lhsStride,
<span class="lineNum">      97 </span>            :     const Scalar* _rhs, Index rhsStride,
<span class="lineNum">      98 </span>            :     Scalar* res,        Index resStride,
<span class="lineNum">      99 </span>            :     const Scalar&amp; alpha, level3_blocking&lt;Scalar,Scalar&gt;&amp; blocking);
<span class="lineNum">     100 </span>            : };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : template &lt;typename Scalar, typename Index, int Mode,
<a name="103"><span class="lineNum">     103 </span>            :           int LhsStorageOrder, bool ConjugateLhs,</a>
<span class="lineNum">     104 </span>            :           int RhsStorageOrder, bool ConjugateRhs, int Version&gt;
<span class="lineNum">     105 </span><span class="lineNoCov">          0 : EIGEN_DONT_INLINE void product_triangular_matrix_matrix&lt;Scalar,Index,Mode,true,</span>
<span class="lineNum">     106 </span>            :                                                         LhsStorageOrder,ConjugateLhs,
<span class="lineNum">     107 </span>            :                                                         RhsStorageOrder,ConjugateRhs,ColMajor,Version&gt;::run(
<span class="lineNum">     108 </span>            :     Index _rows, Index _cols, Index _depth,
<span class="lineNum">     109 </span>            :     const Scalar* _lhs, Index lhsStride,
<span class="lineNum">     110 </span>            :     const Scalar* _rhs, Index rhsStride,
<span class="lineNum">     111 </span>            :     Scalar* _res,        Index resStride,
<span class="lineNum">     112 </span>            :     const Scalar&amp; alpha, level3_blocking&lt;Scalar,Scalar&gt;&amp; blocking)
<span class="lineNum">     113 </span>            :   {
<span class="lineNum">     114 </span>            :     // strip zeros
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     Index diagSize  = (std::min)(_rows,_depth);</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     Index rows      = IsLower ? _rows : diagSize;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     Index depth     = IsLower ? diagSize : _depth;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     Index cols      = _cols;</span>
<span class="lineNum">     119 </span>            :     
<span class="lineNum">     120 </span>            :     typedef const_blas_data_mapper&lt;Scalar, Index, LhsStorageOrder&gt; LhsMapper;
<span class="lineNum">     121 </span>            :     typedef const_blas_data_mapper&lt;Scalar, Index, RhsStorageOrder&gt; RhsMapper;
<span class="lineNum">     122 </span>            :     typedef blas_data_mapper&lt;typename Traits::ResScalar, Index, ColMajor&gt; ResMapper;
<span class="lineNum">     123 </span>            :     LhsMapper lhs(_lhs,lhsStride);
<span class="lineNum">     124 </span>            :     RhsMapper rhs(_rhs,rhsStride);
<span class="lineNum">     125 </span>            :     ResMapper res(_res, resStride);
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     Index kc = blocking.kc();                   // cache block size along the K direction</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction</span>
<span class="lineNum">     129 </span>            :     // The small panel size must not be larger than blocking size.
<span class="lineNum">     130 </span>            :     // Usually this should never be the case because SmallPanelWidth^2 is very small
<span class="lineNum">     131 </span>            :     // compared to L2 cache size, but let's be safe:
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     Index panelWidth = (std::min)(Index(SmallPanelWidth),(std::min)(kc,mc));</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     std::size_t sizeA = kc*mc;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     std::size_t sizeB = kc*cols;</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :     // To work around an &quot;error: member reference base type 'Matrix&lt;...&gt;
<span class="lineNum">     141 </span>            :     // (Eigen::internal::constructor_without_unaligned_array_assert (*)())' is
<span class="lineNum">     142 </span>            :     // not a structure or union&quot; compilation error in nvcc (tested V8.0.61),
<span class="lineNum">     143 </span>            :     // create a dummy internal::constructor_without_unaligned_array_assert
<span class="lineNum">     144 </span>            :     // object to pass to the Matrix constructor.
<span class="lineNum">     145 </span>            :     internal::constructor_without_unaligned_array_assert a;
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     Matrix&lt;Scalar,SmallPanelWidth,SmallPanelWidth,LhsStorageOrder&gt; triangularBuffer(a);</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     triangularBuffer.setZero();</span>
<span class="lineNum">     148 </span>            :     if((Mode&amp;ZeroDiag)==ZeroDiag)
<span class="lineNum">     149 </span>            :       triangularBuffer.diagonal().setZero();
<span class="lineNum">     150 </span>            :     else
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       triangularBuffer.diagonal().setOnes();</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :     gebp_kernel&lt;Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs&gt; gebp_kernel;
<span class="lineNum">     154 </span>            :     gemm_pack_lhs&lt;Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder&gt; pack_lhs;
<span class="lineNum">     155 </span>            :     gemm_pack_rhs&lt;Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder&gt; pack_rhs;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     for(Index k2=IsLower ? depth : 0;</span>
<span class="lineNum">     158 </span>            :         IsLower ? k2&gt;0 : k2&lt;depth;
<span class="lineNum">     159 </span>            :         IsLower ? k2-=kc : k2+=kc)
<span class="lineNum">     160 </span>            :     {
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       Index actual_kc = (std::min)(IsLower ? k2 : depth-k2, kc);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       Index actual_k2 = IsLower ? k2-actual_kc : k2;</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :       // align blocks with the end of the triangular part for trapezoidal lhs
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       if((!IsLower)&amp;&amp;(k2&lt;rows)&amp;&amp;(k2+actual_kc&gt;rows))</span>
<span class="lineNum">     166 </span>            :       {
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         actual_kc = rows-k2;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         k2 = k2+actual_kc-kc;</span>
<span class="lineNum">     169 </span>            :       }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :       pack_rhs(blockB, rhs.getSubMapper(actual_k2,0), actual_kc, cols);</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :       // the selected lhs's panel has to be split in three different parts:
<span class="lineNum">     174 </span>            :       //  1 - the part which is zero =&gt; skip it
<span class="lineNum">     175 </span>            :       //  2 - the diagonal block =&gt; special kernel
<span class="lineNum">     176 </span>            :       //  3 - the dense panel below (lower case) or above (upper case) the diagonal block =&gt; GEPP
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :       // the block diagonal, if any:
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       if(IsLower || actual_k2&lt;rows)</span>
<span class="lineNum">     180 </span>            :       {
<span class="lineNum">     181 </span>            :         // for each small vertical panels of lhs
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         for (Index k1=0; k1&lt;actual_kc; k1+=panelWidth)</span>
<span class="lineNum">     183 </span>            :         {
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :           Index actualPanelWidth = std::min&lt;Index&gt;(actual_kc-k1, panelWidth);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :           Index lengthTarget = IsLower ? actual_kc-k1-actualPanelWidth : k1;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :           Index startBlock   = actual_k2+k1;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :           Index blockBOffset = k1;</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :           // =&gt; GEBP with the micro triangular block
<span class="lineNum">     190 </span>            :           // The trick is to pack this micro block while filling the opposite triangular part with zeros.
<span class="lineNum">     191 </span>            :           // To this end we do an extra triangular copy to a small temporary buffer
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :           for (Index k=0;k&lt;actualPanelWidth;++k)</span>
<span class="lineNum">     193 </span>            :           {
<span class="lineNum">     194 </span>            :             if (SetDiag)
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :               triangularBuffer.coeffRef(k,k) = lhs(startBlock+k,startBlock+k);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :             for (Index i=IsLower ? k+1 : 0; IsLower ? i&lt;actualPanelWidth : i&lt;k; ++i)</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :               triangularBuffer.coeffRef(i,k) = lhs(startBlock+i,startBlock+k);</span>
<span class="lineNum">     198 </span>            :           }
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :           pack_lhs(blockA, LhsMapper(triangularBuffer.data(), triangularBuffer.outerStride()), actualPanelWidth, actualPanelWidth);</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :           gebp_kernel(res.getSubMapper(startBlock, 0), blockA, blockB,</span>
<span class="lineNum">     202 </span>            :                       actualPanelWidth, actualPanelWidth, cols, alpha,
<span class="lineNum">     203 </span>            :                       actualPanelWidth, actual_kc, 0, blockBOffset);
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :           // GEBP with remaining micro panel
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :           if (lengthTarget&gt;0)</span>
<span class="lineNum">     207 </span>            :           {
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :             Index startTarget  = IsLower ? actual_k2+k1+actualPanelWidth : actual_k2;</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :             pack_lhs(blockA, lhs.getSubMapper(startTarget,startBlock), actualPanelWidth, lengthTarget);</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :             gebp_kernel(res.getSubMapper(startTarget, 0), blockA, blockB,</span>
<span class="lineNum">     213 </span>            :                         lengthTarget, actualPanelWidth, cols, alpha,
<span class="lineNum">     214 </span>            :                         actualPanelWidth, actual_kc, 0, blockBOffset);
<span class="lineNum">     215 </span>            :           }
<span class="lineNum">     216 </span>            :         }
<span class="lineNum">     217 </span>            :       }
<span class="lineNum">     218 </span>            :       // the part below (lower case) or above (upper case) the diagonal =&gt; GEPP
<span class="lineNum">     219 </span>            :       {
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         Index start = IsLower ? k2 : 0;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         Index end   = IsLower ? rows : (std::min)(actual_k2,rows);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         for(Index i2=start; i2&lt;end; i2+=mc)</span>
<span class="lineNum">     223 </span>            :         {
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :           const Index actual_mc = (std::min)(i2+mc,end)-i2;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :           gemm_pack_lhs&lt;Scalar, Index, LhsMapper, Traits::mr,Traits::LhsProgress, LhsStorageOrder,false&gt;()</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             (blockA, lhs.getSubMapper(i2, actual_k2), actual_kc, actual_mc);</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :           gebp_kernel(res.getSubMapper(i2, 0), blockA, blockB, actual_mc,</span>
<span class="lineNum">     229 </span>            :                       actual_kc, cols, alpha, -1, -1, 0, 0);
<span class="lineNum">     230 </span>            :         }
<span class="lineNum">     231 </span>            :       }
<span class="lineNum">     232 </span>            :     }
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : // implements col-major += alpha * op(general) * op(triangular)
<span class="lineNum">     236 </span>            : template &lt;typename Scalar, typename Index, int Mode,
<span class="lineNum">     237 </span>            :           int LhsStorageOrder, bool ConjugateLhs,
<span class="lineNum">     238 </span>            :           int RhsStorageOrder, bool ConjugateRhs, int Version&gt;
<span class="lineNum">     239 </span>            : struct product_triangular_matrix_matrix&lt;Scalar,Index,Mode,false,
<span class="lineNum">     240 </span>            :                                         LhsStorageOrder,ConjugateLhs,
<span class="lineNum">     241 </span>            :                                         RhsStorageOrder,ConjugateRhs,ColMajor,Version&gt;
<span class="lineNum">     242 </span>            : {
<span class="lineNum">     243 </span>            :   typedef gebp_traits&lt;Scalar,Scalar&gt; Traits;
<span class="lineNum">     244 </span>            :   enum {
<span class="lineNum">     245 </span>            :     SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
<span class="lineNum">     246 </span>            :     IsLower = (Mode&amp;Lower) == Lower,
<span class="lineNum">     247 </span>            :     SetDiag = (Mode&amp;(ZeroDiag|UnitDiag)) ? 0 : 1
<span class="lineNum">     248 </span>            :   };
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :   static EIGEN_DONT_INLINE void run(
<span class="lineNum">     251 </span>            :     Index _rows, Index _cols, Index _depth,
<span class="lineNum">     252 </span>            :     const Scalar* _lhs, Index lhsStride,
<span class="lineNum">     253 </span>            :     const Scalar* _rhs, Index rhsStride,
<span class="lineNum">     254 </span>            :     Scalar* res,        Index resStride,
<span class="lineNum">     255 </span>            :     const Scalar&amp; alpha, level3_blocking&lt;Scalar,Scalar&gt;&amp; blocking);
<span class="lineNum">     256 </span>            : };
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : template &lt;typename Scalar, typename Index, int Mode,
<span class="lineNum">     259 </span>            :           int LhsStorageOrder, bool ConjugateLhs,
<span class="lineNum">     260 </span>            :           int RhsStorageOrder, bool ConjugateRhs, int Version&gt;
<span class="lineNum">     261 </span>            : EIGEN_DONT_INLINE void product_triangular_matrix_matrix&lt;Scalar,Index,Mode,false,
<span class="lineNum">     262 </span>            :                                                         LhsStorageOrder,ConjugateLhs,
<span class="lineNum">     263 </span>            :                                                         RhsStorageOrder,ConjugateRhs,ColMajor,Version&gt;::run(
<span class="lineNum">     264 </span>            :     Index _rows, Index _cols, Index _depth,
<span class="lineNum">     265 </span>            :     const Scalar* _lhs, Index lhsStride,
<span class="lineNum">     266 </span>            :     const Scalar* _rhs, Index rhsStride,
<span class="lineNum">     267 </span>            :     Scalar* _res,        Index resStride,
<span class="lineNum">     268 </span>            :     const Scalar&amp; alpha, level3_blocking&lt;Scalar,Scalar&gt;&amp; blocking)
<span class="lineNum">     269 </span>            :   {
<span class="lineNum">     270 </span>            :     const Index PacketBytes = packet_traits&lt;Scalar&gt;::size*sizeof(Scalar);
<span class="lineNum">     271 </span>            :     // strip zeros
<span class="lineNum">     272 </span>            :     Index diagSize  = (std::min)(_cols,_depth);
<span class="lineNum">     273 </span>            :     Index rows      = _rows;
<span class="lineNum">     274 </span>            :     Index depth     = IsLower ? _depth : diagSize;
<span class="lineNum">     275 </span>            :     Index cols      = IsLower ? diagSize : _cols;
<span class="lineNum">     276 </span>            :     
<span class="lineNum">     277 </span>            :     typedef const_blas_data_mapper&lt;Scalar, Index, LhsStorageOrder&gt; LhsMapper;
<span class="lineNum">     278 </span>            :     typedef const_blas_data_mapper&lt;Scalar, Index, RhsStorageOrder&gt; RhsMapper;
<span class="lineNum">     279 </span>            :     typedef blas_data_mapper&lt;typename Traits::ResScalar, Index, ColMajor&gt; ResMapper;
<span class="lineNum">     280 </span>            :     LhsMapper lhs(_lhs,lhsStride);
<span class="lineNum">     281 </span>            :     RhsMapper rhs(_rhs,rhsStride);
<span class="lineNum">     282 </span>            :     ResMapper res(_res, resStride);
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :     Index kc = blocking.kc();                   // cache block size along the K direction
<span class="lineNum">     285 </span>            :     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :     std::size_t sizeA = kc*mc;
<span class="lineNum">     288 </span>            :     std::size_t sizeB = kc*cols+EIGEN_MAX_ALIGN_BYTES/sizeof(Scalar);
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());
<span class="lineNum">     291 </span>            :     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     internal::constructor_without_unaligned_array_assert a;
<span class="lineNum">     294 </span>            :     Matrix&lt;Scalar,SmallPanelWidth,SmallPanelWidth,RhsStorageOrder&gt; triangularBuffer(a);
<span class="lineNum">     295 </span>            :     triangularBuffer.setZero();
<span class="lineNum">     296 </span>            :     if((Mode&amp;ZeroDiag)==ZeroDiag)
<span class="lineNum">     297 </span>            :       triangularBuffer.diagonal().setZero();
<span class="lineNum">     298 </span>            :     else
<span class="lineNum">     299 </span>            :       triangularBuffer.diagonal().setOnes();
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     gebp_kernel&lt;Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs&gt; gebp_kernel;
<span class="lineNum">     302 </span>            :     gemm_pack_lhs&lt;Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder&gt; pack_lhs;
<span class="lineNum">     303 </span>            :     gemm_pack_rhs&lt;Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder&gt; pack_rhs;
<span class="lineNum">     304 </span>            :     gemm_pack_rhs&lt;Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder,false,true&gt; pack_rhs_panel;
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :     for(Index k2=IsLower ? 0 : depth;
<span class="lineNum">     307 </span>            :         IsLower ? k2&lt;depth  : k2&gt;0;
<span class="lineNum">     308 </span>            :         IsLower ? k2+=kc   : k2-=kc)
<span class="lineNum">     309 </span>            :     {
<span class="lineNum">     310 </span>            :       Index actual_kc = (std::min)(IsLower ? depth-k2 : k2, kc);
<span class="lineNum">     311 </span>            :       Index actual_k2 = IsLower ? k2 : k2-actual_kc;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :       // align blocks with the end of the triangular part for trapezoidal rhs
<span class="lineNum">     314 </span>            :       if(IsLower &amp;&amp; (k2&lt;cols) &amp;&amp; (actual_k2+actual_kc&gt;cols))
<span class="lineNum">     315 </span>            :       {
<span class="lineNum">     316 </span>            :         actual_kc = cols-k2;
<span class="lineNum">     317 </span>            :         k2 = actual_k2 + actual_kc - kc;
<span class="lineNum">     318 </span>            :       }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :       // remaining size
<span class="lineNum">     321 </span>            :       Index rs = IsLower ? (std::min)(cols,actual_k2) : cols - k2;
<span class="lineNum">     322 </span>            :       // size of the triangular part
<span class="lineNum">     323 </span>            :       Index ts = (IsLower &amp;&amp; actual_k2&gt;=cols) ? 0 : actual_kc;
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :       Scalar* geb = blockB+ts*ts;
<span class="lineNum">     326 </span>            :       geb = geb + internal::first_aligned&lt;PacketBytes&gt;(geb,PacketBytes/sizeof(Scalar));
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :       pack_rhs(geb, rhs.getSubMapper(actual_k2,IsLower ? 0 : k2), actual_kc, rs);
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :       // pack the triangular part of the rhs padding the unrolled blocks with zeros
<span class="lineNum">     331 </span>            :       if(ts&gt;0)
<span class="lineNum">     332 </span>            :       {
<span class="lineNum">     333 </span>            :         for (Index j2=0; j2&lt;actual_kc; j2+=SmallPanelWidth)
<span class="lineNum">     334 </span>            :         {
<span class="lineNum">     335 </span>            :           Index actualPanelWidth = std::min&lt;Index&gt;(actual_kc-j2, SmallPanelWidth);
<span class="lineNum">     336 </span>            :           Index actual_j2 = actual_k2 + j2;
<span class="lineNum">     337 </span>            :           Index panelOffset = IsLower ? j2+actualPanelWidth : 0;
<span class="lineNum">     338 </span>            :           Index panelLength = IsLower ? actual_kc-j2-actualPanelWidth : j2;
<span class="lineNum">     339 </span>            :           // general part
<span class="lineNum">     340 </span>            :           pack_rhs_panel(blockB+j2*actual_kc,
<span class="lineNum">     341 </span>            :                          rhs.getSubMapper(actual_k2+panelOffset, actual_j2),
<span class="lineNum">     342 </span>            :                          panelLength, actualPanelWidth,
<span class="lineNum">     343 </span>            :                          actual_kc, panelOffset);
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :           // append the triangular part via a temporary buffer
<span class="lineNum">     346 </span>            :           for (Index j=0;j&lt;actualPanelWidth;++j)
<span class="lineNum">     347 </span>            :           {
<span class="lineNum">     348 </span>            :             if (SetDiag)
<span class="lineNum">     349 </span>            :               triangularBuffer.coeffRef(j,j) = rhs(actual_j2+j,actual_j2+j);
<span class="lineNum">     350 </span>            :             for (Index k=IsLower ? j+1 : 0; IsLower ? k&lt;actualPanelWidth : k&lt;j; ++k)
<span class="lineNum">     351 </span>            :               triangularBuffer.coeffRef(k,j) = rhs(actual_j2+k,actual_j2+j);
<span class="lineNum">     352 </span>            :           }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :           pack_rhs_panel(blockB+j2*actual_kc,
<span class="lineNum">     355 </span>            :                          RhsMapper(triangularBuffer.data(), triangularBuffer.outerStride()),
<span class="lineNum">     356 </span>            :                          actualPanelWidth, actualPanelWidth,
<span class="lineNum">     357 </span>            :                          actual_kc, j2);
<span class="lineNum">     358 </span>            :         }
<span class="lineNum">     359 </span>            :       }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :       for (Index i2=0; i2&lt;rows; i2+=mc)
<span class="lineNum">     362 </span>            :       {
<span class="lineNum">     363 </span>            :         const Index actual_mc = (std::min)(mc,rows-i2);
<span class="lineNum">     364 </span>            :         pack_lhs(blockA, lhs.getSubMapper(i2, actual_k2), actual_kc, actual_mc);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :         // triangular kernel
<span class="lineNum">     367 </span>            :         if(ts&gt;0)
<span class="lineNum">     368 </span>            :         {
<span class="lineNum">     369 </span>            :           for (Index j2=0; j2&lt;actual_kc; j2+=SmallPanelWidth)
<span class="lineNum">     370 </span>            :           {
<span class="lineNum">     371 </span>            :             Index actualPanelWidth = std::min&lt;Index&gt;(actual_kc-j2, SmallPanelWidth);
<span class="lineNum">     372 </span>            :             Index panelLength = IsLower ? actual_kc-j2 : j2+actualPanelWidth;
<span class="lineNum">     373 </span>            :             Index blockOffset = IsLower ? j2 : 0;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :             gebp_kernel(res.getSubMapper(i2, actual_k2 + j2),
<span class="lineNum">     376 </span>            :                         blockA, blockB+j2*actual_kc,
<span class="lineNum">     377 </span>            :                         actual_mc, panelLength, actualPanelWidth,
<span class="lineNum">     378 </span>            :                         alpha,
<span class="lineNum">     379 </span>            :                         actual_kc, actual_kc,  // strides
<span class="lineNum">     380 </span>            :                         blockOffset, blockOffset);// offsets
<span class="lineNum">     381 </span>            :           }
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            :         gebp_kernel(res.getSubMapper(i2, IsLower ? 0 : k2),
<span class="lineNum">     384 </span>            :                     blockA, geb, actual_mc, actual_kc, rs,
<span class="lineNum">     385 </span>            :                     alpha,
<span class="lineNum">     386 </span>            :                     -1, -1, 0, 0);
<span class="lineNum">     387 </span>            :       }
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            :   }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : /***************************************************************************
<span class="lineNum">     392 </span>            : * Wrapper to product_triangular_matrix_matrix
<span class="lineNum">     393 </span>            : ***************************************************************************/
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : } // end namespace internal
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : namespace internal {
<span class="lineNum">     398 </span>            : template&lt;int Mode, bool LhsIsTriangular, typename Lhs, typename Rhs&gt;
<a name="399"><span class="lineNum">     399 </span>            : struct triangular_product_impl&lt;Mode,LhsIsTriangular,Lhs,false,Rhs,false&gt;</a>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   template&lt;typename Dest&gt; static void run(Dest&amp; dst, const Lhs &amp;a_lhs, const Rhs &amp;a_rhs, const typename Dest::Scalar&amp; alpha)</span>
<span class="lineNum">     402 </span>            :   {
<span class="lineNum">     403 </span>            :     typedef typename Lhs::Scalar  LhsScalar;
<span class="lineNum">     404 </span>            :     typedef typename Rhs::Scalar  RhsScalar;
<span class="lineNum">     405 </span>            :     typedef typename Dest::Scalar Scalar;
<span class="lineNum">     406 </span>            :     
<span class="lineNum">     407 </span>            :     typedef internal::blas_traits&lt;Lhs&gt; LhsBlasTraits;
<span class="lineNum">     408 </span>            :     typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;
<span class="lineNum">     409 </span>            :     typedef typename internal::remove_all&lt;ActualLhsType&gt;::type ActualLhsTypeCleaned;
<span class="lineNum">     410 </span>            :     typedef internal::blas_traits&lt;Rhs&gt; RhsBlasTraits;
<span class="lineNum">     411 </span>            :     typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
<span class="lineNum">     412 </span>            :     typedef typename internal::remove_all&lt;ActualRhsType&gt;::type ActualRhsTypeCleaned;
<span class="lineNum">     413 </span>            :     
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     typename internal::add_const_on_value_type&lt;ActualLhsType&gt;::type lhs = LhsBlasTraits::extract(a_lhs);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     typename internal::add_const_on_value_type&lt;ActualRhsType&gt;::type rhs = RhsBlasTraits::extract(a_rhs);</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     LhsScalar lhs_alpha = LhsBlasTraits::extractScalarFactor(a_lhs);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     RhsScalar rhs_alpha = RhsBlasTraits::extractScalarFactor(a_rhs);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     Scalar actualAlpha = alpha * lhs_alpha * rhs_alpha;</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :     typedef internal::gemm_blocking_space&lt;(Dest::Flags&amp;RowMajorBit) ? RowMajor : ColMajor,Scalar,Scalar,
<span class="lineNum">     422 </span>            :               Lhs::MaxRowsAtCompileTime, Rhs::MaxColsAtCompileTime, Lhs::MaxColsAtCompileTime,4&gt; BlockingType;
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :     enum { IsLower = (Mode&amp;Lower) == Lower };
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     Index stripedRows  = ((!LhsIsTriangular) || (IsLower))  ? lhs.rows() : (std::min)(lhs.rows(),lhs.cols());</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     Index stripedCols  = ((LhsIsTriangular)  || (!IsLower)) ? rhs.cols() : (std::min)(rhs.cols(),rhs.rows());</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     Index stripedDepth = LhsIsTriangular ? ((!IsLower) ? lhs.cols() : (std::min)(lhs.cols(),lhs.rows()))</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                                          : ((IsLower)  ? rhs.rows() : (std::min)(rhs.rows(),rhs.cols()));</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     BlockingType blocking(stripedRows, stripedCols, stripedDepth, 1, false);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     internal::product_triangular_matrix_matrix&lt;Scalar, Index,</span>
<span class="lineNum">     433 </span>            :       Mode, LhsIsTriangular,
<span class="lineNum">     434 </span>            :       (internal::traits&lt;ActualLhsTypeCleaned&gt;::Flags&amp;RowMajorBit) ? RowMajor : ColMajor, LhsBlasTraits::NeedToConjugate,
<span class="lineNum">     435 </span>            :       (internal::traits&lt;ActualRhsTypeCleaned&gt;::Flags&amp;RowMajorBit) ? RowMajor : ColMajor, RhsBlasTraits::NeedToConjugate,
<span class="lineNum">     436 </span>            :       (internal::traits&lt;Dest          &gt;::Flags&amp;RowMajorBit) ? RowMajor : ColMajor&gt;
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       ::run(</span>
<span class="lineNum">     438 </span>            :         stripedRows, stripedCols, stripedDepth,   // sizes
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         &amp;lhs.coeffRef(0,0), lhs.outerStride(),    // lhs info</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         &amp;rhs.coeffRef(0,0), rhs.outerStride(),    // rhs info</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         &amp;dst.coeffRef(0,0), dst.outerStride(),    // result info</span>
<span class="lineNum">     442 </span>            :         actualAlpha, blocking
<span class="lineNum">     443 </span>            :       );
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :     // Apply correction if the diagonal is unit and a scalar factor was nested:
<span class="lineNum">     446 </span>            :     if ((Mode&amp;UnitDiag)==UnitDiag)
<span class="lineNum">     447 </span>            :     {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       if (LhsIsTriangular &amp;&amp; lhs_alpha!=LhsScalar(1))</span>
<span class="lineNum">     449 </span>            :       {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         Index diagSize = (std::min)(lhs.rows(),lhs.cols());</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         dst.topRows(diagSize) -= ((lhs_alpha-LhsScalar(1))*a_rhs).topRows(diagSize);</span>
<span class="lineNum">     452 </span>            :       }
<span class="lineNum">     453 </span>            :       else if ((!LhsIsTriangular) &amp;&amp; rhs_alpha!=RhsScalar(1))
<span class="lineNum">     454 </span>            :       {
<span class="lineNum">     455 </span>            :         Index diagSize = (std::min)(rhs.rows(),rhs.cols());
<span class="lineNum">     456 </span>            :         dst.leftCols(diagSize) -= (rhs_alpha-RhsScalar(1))*a_lhs.leftCols(diagSize);
<span class="lineNum">     457 </span>            :       }
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     460 </span>            : };
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : } // end namespace internal
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : } // end namespace Eigen
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : #endif // EIGEN_TRIANGULAR_MATRIX_MATRIX_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
